
HILFE ZU DEM BEFEHL LS AUFRUFEN:
man ls 		- man=manual, ls=ein Befehl

EINE AUSGABE AN EINEN ANDEREN BEFEHL WEITERLEITEN:
| 			- pipe

DEN AKTUELLEN ORDNER AUSGEBEN, IN DEM MAN SICH BEFINDET:
pwd 			- Print Working Directory
			  user@laptop:~$ pwd
			  /home/user 

DEN INHALT EINES VERZEICHNISSES AUSGEBEN:
ls				- zeigt Inhalt eines Verzeichnisses an
	ls – l			- Datei-Information in Langform ausgeben
	ls – a			- Listet verstecke Dateien und Verzeichnisse wie . oder .. auf
	ls – i 			- Dateinummer zeigt I-Node Nummer
	ls /xyz			- Inhalt eins anderen Verzeichnisses ausgeben.

DEN ORDNER WECHSELN:
cd				- wechselt zwischen Verzeichnissen
	cd .. 			- Wechsel ins übergeordnete Verzeichnis
	cd /xyz			- Wechsel ins Verzeichnis xyz
	cd - 			- Wechsel ins vorherige Verzeichnis
	cd ~ 			- Wechselt ins Home Verzeichnis
	cd $Home		- Wechselt auch ins Home Verzeichnis

EINE NEUE DATEI BEISPIEL.TXT ANLEGEN ODER ZUGRIFFSZEITPUNKT ÄNDERN:
touch beispiel.txt
cat > beispiel.txt

ZEIGE DEN INHALT EINER TEXTDATEI BSP.TXT AN:
cat bsp.txt

VERBINDE ZWEI TEXTDATEIEN 1.TXT UND 2.TXT IN 3.TXT MITEINANDER:
cat 1.txt 2.txt > 3.txt

VERBINDE ZWEI TEXTDATEIEN 1.TXT UND 2.TXT IN 3.TXT UND GEBE SIE UMGEKEHRT WIEDER AUS:
tac 1.txt 2.txt > 3.txt

TEILE EINE DATEI TEST.TXT AUF IN MEHRERE KLEINERE DATEIEN / GLEICHEN ZEILENABSTÄNDEN ZU NEU.TXT:
split -b 160 test.txt neu.txt
split -l 3 test.txt neu.txt

SORTIERE EINE DATEI SPALTEN.TXT:
sort spalten.txt -k2 -n -k1 spalten.txt

I-NODE METADATEN EINER DATEI TEST ANZEIGEN LASSEN:
stat test		- zeigt Inodemetadaten

ZEIGE INFORMATIONEN (ANZAHL ZEILEN, WÖRTER ETC...) ÜBER DEN INHALT EINER DATEI AN:
wc				- Word Count zeigt Informationen über den Inhalt einer Datei an
	wc -l			- zählt die Zeilen in der Datei
	wc -c			- zählt die Bytes in der Datei
	wc -m			- zählt die Länge der längsten Zeile aus
	wc -L			- gibt die Länge der längsten Zeile aus
	wc -w			- zählt die Worte in der Datei

ZEIGE EINEN AUSSCHNITT EINER DATEI AN MIT DER MÖGLICHKEIT ZUR NAVIGATION:
Zeigt Inhalte großer Dateien pro Seite an:
less				- zeigt einen Ausschnitt der Datei mit der Möglichkeit zu navigieren

ERSTELLE EINE VERSCHLÜSSELTE NETZWERKVERBINDUNG ZU EINEM ENTFERNTEN GERÄT:
ssh -l username -p port url

LAUFENDE PROZESSE ANZEIGEN:
ps				- zeigt laufende Prozesse innerhalb eines Terminal Prozesses

EINEN PROZESS MIT DER ID 275 BEENDEN:
kill -9 275

ÜBERSICHT DER AUF DEM SYSTEM LAUFENDEN PROZESSE:
top 

DATEISUCHE NACH ABC.TXT AUF DESKTOP MIT ABSOLUTEM PFAD:
find /home/user/Desktop/abc.txt 

DATEISUCHE MIT NAME ABC MIT UNBEKANNTER ENDUNG:
find abc.*

DATEISUCHE MIT UNBEKANNTEM NAMEN ABER BEKANNTER ENDUNG TXT:
find *.txt 

DATEISUCHE NACH BESTIMMTEM USER BOB:
find -user bob

DATEISUCHE NACH ALLEN DATEIEN DIE GRÖẞER SIND ALS 500 BYTES:
find -size +500c

DATEISUCHE NACH TYP FILE:
find -type f			- f für file oder d für directory

DIE LETZTEN AUSGEFÜHRTEN BEFEHLE ANZEIGEN:
history

NETZWERKEINSTELLUNGEN ANZEIGEN LASSEN:
ifconfig

KERNELINFORMATIONEN ANZEIGEN LASSEN:
uname -a

FREIER ARBEITSSPEICHER ANZEIGEN LASSEN:
free

SUCHE NACH ZEICHENKETTEN "WORT" ODER "PW" IN BSP.TXT:
grep -E "wort|pw" bsp.txt

SUCHE NACH ZEICHENKETTE "ABC" IN BSP.TXT:
grep "abc" bsp.txt

ZEIGE DIE LETZTE ZEILE EINER DATEI BSP.TXT AN:
tail -n1 bsp.txt

LEGE EINEN NEUEN ORDNER BSP AN:
mkdir bsp 

LÖSCHE EINEN ORDNER BSP:
rmdir bsp

LÖSCHE EINE DATEI DATEI.TXT:
rm datei.txt

LÖSCHE EINEN ORDNER BSP MIT ALLEN INHALTEN:
rm -R bsp

FÜGE DIE DATEI DEF.TXT ALS ZWEITE SPALTE IN ABC.TXT EIN:
paste abc.txt def.txt

KOPIERE EINE DATEI FILE.TXT VON QUELLE NACH ZIEL:
cp quelle/file.txt ziel/file.txt

TRANSFERIERE EINE DATEI FILE.TXT VON QUELLE NACH ZIEL:
mv quelle/file.txt ziel/file.txt

BENNENE EINE DATEI FILE.TXT ZU NEW_FILE.TXT UM:
mv file.txt new_file.txt

ERSTELLE EINEN SYMBOLISCHEN LINK AUF EINE DATEI:
ln -s			- erzeugt nur einen symbolischen link (wird meistens genutzt)
ln -l			- zeigt Anzahl an Verweisen auf eine Datei

WIE WIRD EIN COMMANDO UNTER ROOT AUSGEFÜHRT?
sudo

WELCHER BENUTZER BIN ICH?
whoami

LEGEN SIE FEST ZU WELCHER GRUPPE SIE GEHÖREN?
id			

WECHSLE ZU DEM BENUTZER STUDENT1:
su student1

LEGE EINEN NEUEN BENUTZER STUDENT1 AN:
adduser student1

LEGE EINE NEUE GRUPPE STUDENTS AN:
addgroup students

ÄNDERE DIE BERECHTIGUNG AUF DIE DATEI BSP.TXT IM SYMBOLISCHEN MODUS --> USER, GROUP UND OTHERS EXECUTE RECHTE HINZUFÜGEN:
chmod ugo+x bsp.txt		- ändert Berechtigung auf eine Datei
	a=all			x=execute
    u=user		w=write
	g=group		r=read
	o=others

ÄNDERE DIE BERECHTIGUNG AUF DIE DATEI BSP.TXT IM SYMBOLISCHEN MODUS --> ANDERE BENUTZER DÜRFEN NICHT MEHR SCHREIBEN:
chmod o-w bsp.txt		- ändert Berechtigung auf eine Datei
	a=all			x=execute
    u=user		w=write
	g=group		r=read
	o=others

ÄNDERE DIE BERECHTIGUNG AUF DIE DATEI BSP.TXT IM SYMBOLISCHEN MODUS --> ALLE DÜRFEN ALLES:
chmod a+rwx bsp.txt		- ändert Berechtigung auf eine Datei
	a=all			x=execute
    u=user		w=write
	g=group		r=read
	o=others

ÄNDERE DIE BERECHTIGUNG AUF DIE DATEI BSP.TXT IM SYMBOLISCHEN MODUS --> DER USER DARF NICHTS MEHR MACHEN:
chmod u-rwx bsp.txt		- ändert Berechtigung auf eine Datei
	a=all			x=execute
    u=user		w=write
	g=group		r=read
	o=others

ÄNDERE DIE BERECHTIGUNG AUF DIE DATEI BSP.TXT IM OKTALMODUS --> USER DARF ALLES, GRUPPE DARF NUR LESEN, ANDERE NICHTS:
chmod 740 bsp.txt
	0=keine
    1=execute
	2=write
	3=execute + write
	4=read
	5=read + execute
	6=read + write
	7=all

ÄNDERE DIE BERECHTIGUNG AUF DIE DATEI BSP.TXT IM OKTALMODUS --> USER, GROUP UND OTHERS DÜRFEN ALLES:
chmod 777 bsp.txt
	0=keine
    1=execute
	2=write
	3=execute + write
	4=read
	5=read + execute
	6=read + write
	7=all

ÄNDERE DIE BERECHTIGUNG AUF DIE DATEI BSP.TXT IM OKTALMODUS --> NUR GRUPPE DARF AUSFÜHREN:
chmod 010 bsp.txt
	0=keine
    1=execute
	2=write
	3=execute + write
	4=read
	5=read + execute
	6=read + write
	7=all

ÄNDERE DEN BESITZER DER DATEI BSP.TXT AUF STUDENT1:
chown student1 bsp.txt

ÄNDERE DIE GRUPPE UND DEN EIGENTÜMER UM IN STUDENT1 UND STUDENTS EINES VERZEICHNISSES BILDER REKURSIV:
chown -R student1:students bilder

ÄNDERE DIE ZUGEHÖRIGKEIT DER GRUPPE STUDENTS ZU EINEM VERZEICHNIS BILDER:
chgrp students bilder

ZEIGE ALLE GRUPPEN DES USERS STUDENT1 AN:
groups student1

ZEIGE DIE SPEICHERBELEGUNG DER DATEI BSP.TXT AN
du bsp.txt

ZEIGE DEN FREIEN SPEICHERPLATZ AN:
df

LEITE DIE ZEICHENFOLGE "HALLO" AN DIE STANDARDAUSGABE WEITER:
echo hallo

ZEIGE ALLE UMGEBUNGSVARIABLEN AN:
printenv

DEN BENUTZER STUDENT1 IN DIE GRUPPE SUDO EINFÜGEN:
usermod -aG sudo student1

STUDENT1 AUS DER SUDO GRUPPE ENTFERNEN:
deluser student1 sudo

INFORMATIONEN ÜBER DIE USER IN DER GRUPPE SUDO ANZEIGEN:
getent group sudo

PYTHON: MACHE VOM STRING ABC DEN ERSTEN BUCHSTABEN ZU EINEM GROẞBUCHSTABEN:
abc.capitalize()

PYTHON: ZAEHLE DEN "IN" SUBSTRING IM STRING ABC:
abc.count("in")

PYTHON: GEBE DIE STARTPOSITION DES SUBSTRINGS "C" IN ABC AN:
abc.find("c")

PYTHON: PRÜFE DEN STRING ABC OB ER AUS ZAHLEN BESTEHT:
abc.isdigit()

PYTHON: PRÜFE EINEN STRING ABC OB ER KLEIN GESCHRIEBEN IST:
abc.islower()

PYTHON: STRING ABC SOLL NUR AUS KLEINBUCHSTABEN BESTEHEN:
abc.lower()

PYTHON: STRING ABC SOLL NUR AUS GROẞBUCHSTABEN BESTEHEN:
abc.upper()

PYTHON: ENTFERNE DIE RECHTSSTEHENDEN LEERZEICHEN AUS ABC:
abc.rstrip()

PYTHON: ENTFERNE DIE LINKSSTEHENDEN LEERZEICHEN AUS ABC:
abc.lstrip()

PYTHON: PRÜFE OB ALLE WÖRTER IM STRING ABC MIT GROẞBUCHSTABEN ANFANGEN:
abc.istitle()

PYTHON: IM STRING ABC SOLLEN ALLE GROẞ- UND KLEINBUCHSTABEN UMGEDREHT WERDEN:
abc.swapcase()

PYTHON: HÄNGE STRING DEF AN STRING ABC AN:
abc.join(def)

PYTHON: GIB DIE LAENGE VON DEM STRING ABC AN:
len(abc)

PYTHON: TAUSCHE A MIT Z IM STRING ABC:
abc.replace("a","z")

PYTHON: DER STRING ABC SOLL AN JEDEM LEERZEICHEN GETRENNT WERDEN UND IN SP GESPEICHERT WERDEN:
sp=abc.split(" ")

PYTHON: GEBE DEN ERSTEN TEIL DES SEPERATORS SP AUS:
print(sp[0])

PYTHON: GEBE DEN STRING ABC UND DEN INTEGER X MIT DER ERSTEN MÖGLICHKEIT AUS:
print("%s%i"%(abc,x))

PYTHON: GEBE DEN STRING ABC UND DEN INTEGER X MIT DER ZWEITEN MÖGLICHKEIT AUS:
print("{}{}".format(abc,x))

PYTHON: GEBE DEN STRING ABC UND DEN INTEGER X MIT DER DRITTEN MÖGLICHKEIT AUS:
print(f"{abc}{x}")

PYTHON: DER STRING "1+1" SOLL AUSGERECHNET WERDEN:
eval("1+1")

PYTHON: DER CODE "PRINT(1+1)" SOLL AUSGEFÜHRT WERDEN:
exec("print(1+1)")

PYTHON: WIE KANN DIE EINGEBETTETE FUNKTION B DER ÜBERGEORDNETEN FUNKTION A DIE VARIABLE X ZUGÄNGLICH MACHEN:
nonlocal x

PYTHON: WIE KANN EINE FUNKTION DEN WERT EINER GLOBALEN VARIABLE X VERÄNDERN:
global x

PYTHON: KOPIERE DIE LISTE X SODASS EIN DUPLIKAT Y MIT EIGENER ID ENTSTEHT:
y=x[:]

PYTHON: ERFASSE DIE ID DES OBJEKTES X AUS:
id(x)

PYTHON: ERFASSE DEN TYP EINER VARIABLE X:
type(x)

PYTHON: DEFINIERE DEN FUNKTIONSKOPF DER FUNTKION ADD(W) MIT BELIEBIG VIELEN PARAMETERN:
def add(*w):

PYTHON: DEFINIERE DEN FUNKTIONSKOPF DER FUNTKION FUNK(W) MIT BELIEBIG VIELEN SCHLÜSSELWÖRTERN:
def funk(**w):

PYTHON: IST EINE LISTE MUTABEL (0) ODER IMMUTABEL (1)?:
0

PYTHON: IST EIN DICTIONARY MUTABEL (0) ODER IMMUTABEL (1)?:
0

PYTHON: IST EIN TUPEL MUTABEL (0) ODER IMMUTABEL (1)?:
1

PYTHON: IST EIN STRING MUTABEL (0) ODER IMMUTABEL (1)?:
1

PYTHON: IST EIN INTEGER MUTABEL (0) ODER IMMUTABEL (1)?:
1

PYTHON: LIST1 = LIST2 --> ID(LIST1) == ID(LIST2):
1
true

PYTHON: LIST1 = LIST2[:] --> ID(LIST1) == ID(LIST2):
0
false

PYTHON: LIST1=[1,2]; LIST2=[1,2] --> ID(LIST1) == ID(LIST2):
0
false

PYTHON: DICT1 = DICT2 --> ID(DICT1) == ID(DICT2):
1
true

PYTHON: DICT1={1:"1"}; DICT2={1:"1"} --> ID(DICT1) == ID(DICT2):
0
false

SCHREIBE DAS ERGEBNIS VON DATE ALLE 5 MINUTEN NACH JEDER VOLLEN STUNDE ZWISCHEN 9 UND 10 UHR IN EINE DATEI LOG.TXT:
5 9-10 * * * date >> log.txt

SCHREIBE DAS ERGEBNIS VON DATE JEDEN SONNTAG UND DONNERSTAG UM 23.59 IN EINE DATEI LOG.TXT:
59 23 * * 0,4 date >> log.txt

SCHREIBE DAS ERGEBNIS VON DATE JEDEN TAG UM MITTERNACHT IN EINE DATEI LOG.TXT:
0 0 * * * date >> log.txt

SCHREIBE DAS ERGEBNIS VON DATE AM 15 DES MONATS APRIL UND SEPTEMBER IN EINE DATEI LOG.TXT:
* * 15 4,9 * date >> log.txt

WELCHER BEFEHL ÖFFNET DEN CRONTAB EDITOR:
crontab -e

BASH: WIE WIRD EINE IF BEDINGUNG GESCHLOSSEN:
fi

BASH: WIE WIRD EINE FOR SCHLEIFE GESCHLOSSEN:
done

BASH: WAS WIRD NACH EINER FOR SCHLEIFE ALS ERSTES GESCHRIEBEN:
do

BASH: WAS WIRD NACH EINER IF BEDINGUNG ALS ERSTES GESCHRIEBEN:
then

BASH: ERHÖHE DIE VARIABLE I UM 1:
i=$(($i+1))

BASH: BASH SCRIPT.SH 25 30 --> RUFE 25 IM SCRIPT AUF:
$1

BASH: BASH SCRIPT.SH 25 30 --> RUFE 30 IM SCRIPT AUF:
$2

BASH: BASH SCRIPT.SH 25 30 --> WAS STEHT IN $0:
script.sh 

BASH: WIE LAUTET DIE ERSTE ZEILE IN EINEM BASH SCRIPT AUS?
#!/bin/bash

BASH: WIE WIRD EINE BENUTZEREINGABE ABGEFRAGT UND IN VARIABLE ZAHL1 ABGESPEICHERT:
read -p zahl1

PYTHON: ERSTELLE EINE LAMBDA FUKTION F DIE X UM PLUS 5 ERHÖHT:
f=lambda x: x+5

PYTHON: IMPORTIERE RANDINT:
from random import randint

PYTHON:  ÖFFNE DAS FILE TEST.TXT UND SPEICHERE DIESE IN OBJ ---> DIESE DATEI SOLL NUR GELESEN WERDEN KÖNNEN:
obj=open("test.txt","r")

PYTHON:  ÖFFNE DAS FILE TEST.TXT UND SPEICHERE DIESE IN OBJ ---> DIESE DATEI SOLL NEU ANGELEGT WERDEN:
obj=open("test.txt","x")

PYTHON:  ÖFFNE DAS FILE TEST.TXT UND SPEICHERE DIESE IN OBJ ---> DIESE DATEI SOLL ÜBERSCHRIEBEN WERDEN KÖNNEN:
obj=open("test.txt","w")

PYTHON:  ÖFFNE DAS FILE TEST.TXT UND SPEICHERE DIESE IN OBJ ---> DIESE DATEI SOLL ERWEITERT WERDEN:
obj=open("test.txt","a")

PYTHON: VERBINDE LISTE1 MIT LISTE2 ZU EINEM DICTIONARY DICT ANHAND EINER FUNKTION:
dict=dict(zip(liste1,liste2))

PYTHON: ERSTELLE AUS DEM TUPEL X EIN DURCHNUMMERIERTES DICTIONARY DICT MITTELS EINER FOR-SCHLEIFE:
for k,v in enumerate(x):dict[k]=v

PYTHON: ERSTELLE EIN DICT Z AUS DEN DICTS X UND Y:
z={**x,**y}

PYTHON: ITERIERE MIT I DURCH DAS TUPEL X:
for i in x:

PYTHON: GEBE DAS DRITTE ELEMENT DES TUPELS X AUS:
print(x[2])

PYTHON: GEBE DAS DRITTE ELEMENT EINER LISTE X AUS:
print(x[2])

PYTHON: GEBE DEN WERT ZUM SCHLÜSSEL "MAIL" EINES DICTIONARYS X AUS:
print(x["mail"])

PYTHON: STRING1="ABC"; STRING2="DEF" --> WAS IST DAS ERGEBNIS VON STRING1+STRING2:
abcdef

PYTHON: GEBE DEN STRING1="ABC" 5 MAL AM BILDSCHIRM AUS OHNE UMBRUCH:
print(string1*5) 

PYTHON: ENTHÄLT STRING2 DEN ZWEITEN BUCHSTABEN VON STRING1:
string1[1] in string2

PYTHON: GEBE DEN DATEIPFAD FÜR C:\PROGRAMME AUS:
print("c:\\programme")

PYTHON: FOR LINE IN MY_DICT.ITEMS(): --> WELCHEN TYP HAT LINE:
tuple

PYTHON: WIE KANN EINE WHILE SCHLEIFE ABGEBROCHEN WERDEN:
break

PYTHON: WIE KANN EINE WHILE SCHLEIFE WEITERHEIN DURCHLAUFEN WERDEN:
continue

PYTHON: DIE KLASSE B() SOLL VON DER KLASSE A() ERBEN:
b(a)

PYTHON: GEBE JEDE DRITTE POSITION IM STRING ABC MITTELS SLICE AUS:
print(abc[::3])

PYTHON: FILTRIERE ALLE ZAHLEN DIE < 4 SIND AUS DER LISTE Y=[1,2,3,4,5] MITTELS EINER LAMBDA FUNC. AUS:
print(list(filter(lambda x: x<4,y)))

